<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Muite | Muite</title><meta name="author" content="Muite"><meta name="copyright" content="Muite"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis事务在 Redis 中，事务通过 MULTI、EXEC、DISCARD 和 WATCH 四个命令来实现。Redis 的事务允许以原子方式执行一系列命令，这意味着这些命令要么全部执行成功，要么一个也不执行。  MULTI：标记事务的开始。之后的所有命令将不会立即执行，而是被放入队列中。 EXEC：执行所有在 MULTI 后面入队的命令，并且以原子的方式执行。如果在这个过程中有命令出错，则其">
<meta property="og:type" content="article">
<meta property="og:title" content="Muite">
<meta property="og:url" content="https://mutesniper.github.io/2025/04/19/redis%E8%A1%A5%E5%85%85/index.html">
<meta property="og:site_name" content="Muite">
<meta property="og:description" content="Redis事务在 Redis 中，事务通过 MULTI、EXEC、DISCARD 和 WATCH 四个命令来实现。Redis 的事务允许以原子方式执行一系列命令，这意味着这些命令要么全部执行成功，要么一个也不执行。  MULTI：标记事务的开始。之后的所有命令将不会立即执行，而是被放入队列中。 EXEC：执行所有在 MULTI 后面入队的命令，并且以原子的方式执行。如果在这个过程中有命令出错，则其">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.alicdn.com/bao/uploaded/i3/2200690044395/O1CN012NL22Q1iKxHYWb17f_!!2200690044395.jpg">
<meta property="article:published_time" content="2025-04-19T04:46:00.000Z">
<meta property="article:modified_time" content="2025-04-19T09:30:30.867Z">
<meta property="article:author" content="Muite">
<meta property="article:tag" content="note">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.alicdn.com/bao/uploaded/i3/2200690044395/O1CN012NL22Q1iKxHYWb17f_!!2200690044395.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "url": "https://mutesniper.github.io/2025/04/19/redis%E8%A1%A5%E5%85%85/",
  "image": "https://img.alicdn.com/bao/uploaded/i3/2200690044395/O1CN012NL22Q1iKxHYWb17f_!!2200690044395.jpg",
  "datePublished": "2025-04-19T04:46:00.000Z",
  "dateModified": "2025-04-19T09:30:30.867Z",
  "author": [
    {
      "@type": "Person",
      "name": "Muite",
      "url": "https://mutesniper.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mutesniper.github.io/2025/04/19/redis%E8%A1%A5%E5%85%85/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Muite',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/1990ee2c41564e328f35ac72f555f170.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://img.alicdn.com/bao/uploaded/i3/2200690044395/O1CN012NL22Q1iKxHYWb17f_!!2200690044395.jpg" onerror="this.onerror=null;this.src='/null'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">Muite</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Untitled</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-19T04:46:00.000Z" title="Created 2025-04-19 12:46:00">2025-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-19T09:30:30.867Z" title="Updated 2025-04-19 17:30:30">2025-04-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java-note/">java-note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>在 Redis 中，事务通过 <code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code> 和 <code>WATCH</code> 四个命令来实现。Redis 的事务允许以原子方式执行一系列命令，这意味着这些命令要么全部执行成功，要么一个也不执行。</p>
<ul>
<li><strong>MULTI</strong>：标记事务的开始。之后的所有命令将不会立即执行，而是被放入队列中。</li>
<li><strong>EXEC</strong>：执行所有在 <code>MULTI</code> 后面入队的命令，并且以原子的方式执行。如果在这个过程中有命令出错，则其他命令仍然会被执行，但是错误的命令不会被执行。</li>
<li><strong>DISCARD</strong>：清除队列中的所有命令，并退出事务状态。</li>
<li><strong>WATCH</strong>：用于检测键是否被修改。如果在 <code>WATCH</code> 之后和 <code>EXEC</code> 之前，某个被 WATCH 的键被修改了，那么整个事务将会失败（即 <code>EXEC</code> 返回空响应）。可以使用<strong>UNWATCH</strong>取消</li>
</ul>
<p>Redis 事务不支持回滚机制，这意味着一旦事务中的命令开始执行，即使后续命令出现错误，之前的命令也不会被撤销。</p>
<p>Redis事务和MySQL事务的区别：</p>
<ol>
<li><strong>原子性</strong><ul>
<li><strong>Redis</strong>: Redis 事务不具备真正的原子性，虽然事务内的命令会按顺序执行，但如果某些命令失败，其他命令依然会执行，不会自动回滚。</li>
<li><strong>MySQL</strong>: MySQL 事务具有完全的原子性，要么所有命令都成功，要么全部失败并回滚。</li>
</ul>
</li>
<li><strong>隔离性</strong><ul>
<li><strong>Redis</strong>: Redis 提供了简单的隔离级别，通过 <code>WATCH</code> 可以监控某些键的变化，防止并发冲突，但并没有复杂的隔离级别如读未提交、读已提交等。</li>
<li><strong>MySQL</strong>: MySQL 支持多种事务隔离级别（读未提交、读已提交、可重复读、串行化），可以根据需求调整隔离级别来控制并发访问的行为。</li>
</ul>
</li>
<li><strong>持久性</strong><ul>
<li><strong>Redis</strong>: 持久化依赖于配置，如 RDB 快照或 AOF 日志，但默认情况下并不是每次写操作都会同步到磁盘上。</li>
<li><strong>MySQL</strong>: 事务提交后，更改会被立即写入日志文件，并根据配置决定何时刷盘，通常来说，MySQL 更注重数据的持久性和安全性。</li>
</ul>
</li>
<li><strong>回滚机制</strong><ul>
<li><strong>Redis</strong>: 不支持回滚，一旦事务开始执行，即使中途出错，已完成的部分也会保留。</li>
<li><strong>MySQL</strong>: 完全支持事务回滚，可以在任何时候撤销尚未提交的更改。</li>
</ul>
</li>
</ol>
<p><strong>redis事务错误类型：</strong></p>
<ul>
<li>用MULTI开启事务后，输入的命令有误，在此命令回车后立即报错。再执行exec所有命令都无法执行。</li>
<li>输入命令时错误并没有发现（语法没有问题，比如自增了一个字符串类型的值）。使用exec执行命令了才发现错误，此时执行成功的命令不会回滚，执行错误的会报错。</li>
</ul>
<p>Redis使用Watch来提供乐观锁定，类似于CAS（Check-and-Set）。</p>
<p>先使用Watch监视key，再开启MULTI，在MULTI和EXEC期间如果key发生改变，则此事务所有命令都失败</p>
<p>exec后，所有watch取消；当客户端连接丢失（比如退出连接），也会取消监视</p>
<h1 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h1><h2 id="MoreKey"><a href="#MoreKey" class="headerlink" title="MoreKey"></a>MoreKey</h2><p><strong>问题：</strong></p>
<p>如何遍历海量数据？keys *可以吗？</p>
<p>– 建议禁用keys *，由于redis单线程，keys复杂度为O（n），如果key过多，使用此命令会造成Redis阻塞，可能引起缓存雪崩甚至数据库宕机</p>
<p>此外flushdb &#x2F; flushall等命令也应限制或禁用</p>
<p>（注意：如果持久化文件中有要禁用的命令，可能导致redis启动失败，应先删除这些命令或者删除持久化文件）</p>
<p>那么keys *用不了，应该用什么呢？</p>
<p>–scan、sscan、hscan、zscan等</p>
<p><code>scan cursor [match pattern] [count count]</code></p>
<p>cursor：游标</p>
<p>pattern：匹配的模式</p>
<p>count：指定从数据集里返回多少元素，默认值为10</p>
<p>scan命令是一个基于游标的迭代器，每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为scan命令的游标参数。</p>
<p>scan返回包含两个元素的数组，第一个元素是用于进行下一次迭代的新游标；第二个元素则是一个数组，这个数组包含了元素。如果新游标返回0，代表迭代已达到末尾。</p>
<p>scan的遍历顺序非常特别，它不是从第零位一直遍历到末尾，而是采用了高位进位加法来遍历。之所以使用这样的特殊方式进行遍历，是考虑到字典的扩容和缩容造成传统游标的改变。具体原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">假设哈希表的大小为 8（即有 8 个槽位，编号为 0 到 7）。我们通过高位进位加法计算游标的变化过程：</span><br><span class="line"></span><br><span class="line">初始状态</span><br><span class="line">当前游标值 c = 0（二进制 0b000）。</span><br><span class="line">第一次迭代</span><br><span class="line">找到最高有效位：c = 0，没有有效位。</span><br><span class="line">加1：将最低有效位设为1，得到新的游标值 c = 1（二进制 0b001）。</span><br><span class="line">第二次迭代</span><br><span class="line">找到最高有效位：c = 1（二进制 0b001），最高有效位是第0位。</span><br><span class="line">加1：将第0位加1，得到新的游标值 c = 2（二进制 0b010）。</span><br><span class="line">第三次迭代</span><br><span class="line">找到最高有效位：c = 2（二进制 0b010），最高有效位是第1位。</span><br><span class="line">加1：将第1位加1，得到新的游标值 c = 4（二进制 0b100）。</span><br><span class="line">第四次迭代</span><br><span class="line">找到最高有效位：c = 4（二进制 0b100），最高有效位是第2位。</span><br><span class="line">加1：将第2位加1，得到新的游标值 c = 0（二进制 0b000，溢出后回绕到0）。</span><br><span class="line">总结</span><br><span class="line">完整的游标变化序列是：0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 0。</span><br><span class="line"></span><br><span class="line">4. 为什么高位进位加法能避免重复和遗漏？</span><br><span class="line">(1) 均匀分布</span><br><span class="line">高位进位加法生成的游标序列并不是简单的线性递增，而是基于二进制的高位优先规则，这使得游标的变化更加随机化且均匀分布在整个哈希表的索引空间中。即使哈希表发生扩容或缩容，这种均匀分布的特性仍然能够保证每个槽位被访问一次且仅一次。</span><br><span class="line"></span><br><span class="line">(2) 动态调整兼容性</span><br><span class="line">扩容：当哈希表扩容时，新的槽位数量是原来的两倍，Redis 会将旧槽位中的元素重新分配到新槽位中。高位进位加法的游标变化模式天然适应这种变化，因为它总是基于当前哈希表的大小进行计算。</span><br><span class="line">缩容：当哈希表缩容时，槽位数量减少一半，但高位进位加法的游标计算方式仍然能够正确映射到新的槽位范围。</span><br></pre></td></tr></table></figure>



<h2 id="BigKey（在最佳实践笔记中已提到）"><a href="#BigKey（在最佳实践笔记中已提到）" class="headerlink" title="BigKey（在最佳实践笔记中已提到）"></a>BigKey（在最佳实践笔记中已提到）</h2><h2 id="BigKey生产调优"><a href="#BigKey生产调优" class="headerlink" title="BigKey生产调优"></a>BigKey生产调优</h2><p>在 Redis 中，Bigkey 的处理和调优是一个重要的运维任务，尤其是在高并发场景下。Redis 提供了一些机制来优化 Bigkey 的删除操作，其中 <strong>Lazy Free</strong> 是一个关键的特性。它通过异步释放内存的方式减少对 Redis 主线程的影响，从而避免阻塞问题。</p>
<p>以下是关于 Bigkey 调优和 Lazy Free 的详细解析：</p>
<p><strong>1. 什么是 Lazy Free？</strong></p>
<p><strong>Lazy Free</strong> 是 Redis 提供的一种机制，用于异步释放键占用的内存。它的核心思想是将资源释放的操作从主线程中移出，交给后台线程执行，从而避免阻塞 Redis 的主线程。</p>
<ul>
<li><p><strong>适用场景</strong>：主要用于删除 Bigkey 或者需要大量时间来释放内存的操作。</p>
</li>
<li><p>优点</p>
<ul>
<li>避免 Redis 主线程被阻塞。</li>
</ul>
</li>
<li><p>提高 Redis 的响应速度和吞吐量。</p>
</li>
</ul>
<p><strong>2. Lazy Free 的实现原理</strong></p>
<p>Redis 的 Lazy Free 机制依赖于以下两个核心组件：</p>
<ol>
<li><strong>引用计数</strong>：Redis 使用引用计数来管理对象的生命周期。当一个对象的引用计数降为 0 时，表示该对象不再被使用，可以安全地释放。</li>
<li><strong>后台线程池</strong>：Redis 在内部维护了一个或多个后台线程（默认是单线程），用于执行异步的内存释放操作。</li>
</ol>
<p>工作流程</p>
<ol>
<li>当调用 <code>UNLINK</code> 或启用 Lazy Free 特性时，Redis 会将目标键从数据库的数据结构中移除，并将其标记为“待释放”状态。</li>
<li>后台线程池接管这些“待释放”的对象，并逐步释放它们占用的内存。</li>
<li>主线程无需等待内存释放完成，直接返回结果给客户端。</li>
</ol>
<p><strong>3. Lazy Free 的配置</strong></p>
<p>Redis 提供了几个配置选项来控制 Lazy Free 的行为。这些选项可以通过修改 <code>redis.conf</code> 文件或者在运行时使用 <code>CONFIG SET</code> 命令动态调整。</p>
<p><strong>(1) lazyfree-lazy-eviction</strong></p>
<ul>
<li><strong>作用</strong>：是否在内存不足时（触发淘汰策略）启用 Lazy Free。</li>
<li><strong>默认值</strong>：<code>no</code></li>
<li><strong>建议</strong>：如果 Redis 实例中存在大量大键，建议开启此选项以避免淘汰操作导致的阻塞。</li>
</ul>
<p><strong>(2) lazyfree-lazy-expire</strong></p>
<ul>
<li><strong>作用</strong>：是否在过期键被删除时启用 Lazy Free。</li>
<li><strong>默认值</strong>：<code>no</code></li>
<li><strong>建议</strong>：如果设置了 TTL 的键较大，建议开启此选项。</li>
</ul>
<p><strong>(3) lazyfree-lazy-server-del</strong></p>
<ul>
<li><strong>作用</strong>：是否在服务器端显式删除键时（如 <code>RENAME</code>、<code>FLUSHDB</code> 等命令）启用 Lazy Free。</li>
<li><strong>默认值</strong>：<code>no</code></li>
<li><strong>建议</strong>：如果频繁执行这些命令并涉及大键，建议开启此选项。</li>
</ul>
<p><strong>(4) replica-lazy-flush</strong></p>
<ul>
<li><strong>作用</strong>：是否在从节点执行全量同步后的 <code>FLUSHALL</code> 或 <code>FLUSHDB</code> 操作时启用 Lazy Free。</li>
<li><strong>默认值</strong>：<code>no</code></li>
<li><strong>建议</strong>：如果从节点数据量较大，建议开启此选项。</li>
</ul>
<p><strong>4. 如何启用 Lazy Free？</strong></p>
<p>Lazy Free 功能可以通过以下两种方式启用：</p>
<p><strong>(1) 修改配置文件</strong></p>
<p>在 <code>redis.conf</code> 文件中添加或修改以下配置项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction yes</span><br><span class="line">lazyfree-lazy-expire yes</span><br><span class="line">lazyfree-lazy-server-del yes</span><br><span class="line">replica-lazy-flush yes</span><br></pre></td></tr></table></figure>

<p><strong>(2) 动态设置</strong></p>
<p>使用 <code>CONFIG SET</code> 命令动态调整配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET lazyfree-lazy-eviction yes</span><br><span class="line">CONFIG SET lazyfree-lazy-expire yes</span><br><span class="line">CONFIG SET lazyfree-lazy-server-del yes</span><br><span class="line">CONFIG SET replica-lazy-flush yes</span><br></pre></td></tr></table></figure>



<p><strong>5. 使用 UNLINK 替代 DEL</strong></p>
<p><code>UNLINK</code> 是 Redis 提供的一个命令，专门用于异步删除键。它是 Lazy Free 的典型应用场景。</p>
<p><strong>示例</strong></p>
<p>假设有一个 Bigkey <code>bigkey</code>，你可以使用以下命令异步删除它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLINK bigkey</span><br></pre></td></tr></table></figure>

<p>与 <code>DEL</code> 不同，<code>UNLINK</code> 不会阻塞 Redis 主线程，而是将删除操作交给后台线程执行。</p>
<p><strong>6. 分批删除 Bigkey</strong></p>
<p>对于包含大量元素的数据结构（如 <code>List</code>、<code>Set</code>、<code>Hash</code> 或 <code>Sorted Set</code>），可以直接使用分批删除的方式来避免一次性删除带来的性能问题。</p>
<p><strong>示例</strong></p>
<p>(1) 分批删除 Hash 的字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 每次删除 100 个字段</span><br><span class="line">HSCAN bigkey 0 COUNT 100</span><br><span class="line">HDEL bigkey field1 field2 ... field100</span><br></pre></td></tr></table></figure>

<p>(2) 分批删除 List 的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每次弹出 100 个元素</span><br><span class="line">LPOP bigkey 100</span><br></pre></td></tr></table></figure>

<p>(3) 分批删除 Set 的成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每次随机移除 100 个成员</span><br><span class="line">SPOP bigkey 100</span><br></pre></td></tr></table></figure>

<p>(4) 分批删除 Sorted Set 的成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每次移除最小的 100 个成员</span><br><span class="line">ZPOPMIN bigkey 100</span><br></pre></td></tr></table></figure>



<p><strong>7. 监控和检测 Bigkey</strong></p>
<p>为了有效管理 Bigkey，定期监控和检测是非常重要的。</p>
<p><strong>(1) 使用 redis-cli –bigkeys</strong></p>
<p>Redis 提供了一个内置工具 <code>--bigkeys</code> 来扫描数据库并报告 Bigkey。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --bigkeys</span><br></pre></td></tr></table></figure>

<p><strong>(2) 使用 MEMORY USAGE</strong></p>
<p>可以使用 <code>MEMORY USAGE</code> 命令查看某个键占用的内存量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MEMORY USAGE bigkey</span><br></pre></td></tr></table></figure>

<p><strong>(3) 使用 Redis 模块</strong></p>
<p>一些 Redis 模块（如 <a target="_blank" rel="noopener" href="https://redis.io/modules/redisgears/">RedisGears</a> 或 <a target="_blank" rel="noopener" href="https://redis.com/redis-enterprise/redis-insight/">RedisInsight</a>）提供了更强大的功能来分析和处理 Bigkey。</p>
<p><strong>8. 总结</strong></p>
<p>通过结合 <strong>Lazy Free</strong> 和其他优化手段，可以有效管理和优化 Bigkey，从而提升 Redis 的性能和稳定性。以下是具体建议：</p>
<ol>
<li><strong>启用 Lazy Free</strong>：根据业务需求调整相关配置选项（如 <code>lazyfree-lazy-eviction</code> 和 <code>lazyfree-lazy-expire</code>）。</li>
<li><strong>使用 UNLINK 替代 DEL</strong>：尽量避免直接使用 <code>DEL</code> 删除大键，改用 <code>UNLINK</code>。</li>
<li><strong>分批删除</strong>：对于复杂数据结构，采用分批删除的方式逐步清理数据。</li>
<li><strong>定期检测 Bigkey</strong>：使用 <code>redis-cli --bigkeys</code> 或其他工具定期检查和优化 Bigkey。</li>
</ol>
<p>通过这些方法，可以显著减少 Bigkey 对 Redis 性能的影响，确保系统的高效运行。</p>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>布隆过滤器（Bloom Filter）是一种空间效率非常高的概率型数据结构，主要用于判断一个元素是否在一个集合中。它能够快速地告诉你某个元素“可能在集合中”或“绝对不在集合中”。布隆过滤器通过允许一定程度的误报（即报告某个元素可能存在但实际上不存在的情况），以换取极低的存储需求和高效的查询速度。</p>
<p><strong>布隆过滤器的工作原理</strong></p>
<ol>
<li><strong>初始化</strong>：创建一个长度为 m 的位数组，并将其所有位初始化为 0。</li>
<li><strong>哈希函数</strong>：选择 k 个独立的哈希函数，这些哈希函数将输入元素映射到位数组的不同位置上。</li>
<li>插入元素<ul>
<li>当要向布隆过滤器中添加一个元素时，使用这 k个哈希函数对该元素进行哈希计算，得到 k个不同的哈希值。</li>
<li>将这些哈希值对应到位数组的位置上的位设置为 1。</li>
</ul>
</li>
<li>查询元素<ul>
<li>要检查一个元素是否存在于布隆过滤器中，同样使用这 k 个哈希函数对该元素进行哈希计算并取模得到k个位。</li>
<li>如果所有对应的位都是 1，则该元素可能存在于集合中；如果有任何一个位是 0，则该元素绝对不在集合中。</li>
</ul>
</li>
</ol>
<p><strong>主要特点</strong></p>
<ul>
<li><strong>空间高效</strong>：相比直接存储元素，布隆过滤器只需要少量的位来表示大量元素的存在情况。</li>
<li><strong>时间高效</strong>：无论是插入还是查询操作的时间复杂度均为 O(k)，其中 k 是哈希函数的数量，通常是一个小常数。</li>
<li><strong>存在误报率</strong>：布隆过滤器可能会错误地认为一个不在集合中的元素存在于集合中，但不会漏报（即将存在的元素报告为不存在）。</li>
<li><strong>无法删除元素</strong>：由于多个元素可能共享同一个位，因此不能简单地通过将位重置为 0 来实现删除操作。</li>
</ul>
</li>
</ul>
<img src="../assets/屏幕截图 2025-04-12 211126-1745051720953.png" alt="屏幕截图 2025-04-12 211126" style="zoom:75%;" />

<p>​	布隆过滤器优点：内存占用少，没有多余key</p>
<p>​	缺点：</p>
<pre><code>    - 实现复杂

    - 存在误判可能（因为哈希函数本身就是散列函数，可能会有碰撞）
    - 不能删除元素
</code></pre>
<h2 id="原理-使用场景"><a href="#原理-使用场景" class="headerlink" title="原理&amp;使用场景"></a>原理&amp;使用场景</h2><p>哈希碰撞：输出值相同，输入值不一定相同；输出值不同，输入值一定不同。</p>
<p>如果只用一个哈希函数，很容易发生哈希碰撞。</p>
<p>建议：</p>
<ul>
<li>使用时不要让实际元素数量远大于初始化bitmap的位数</li>
<li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，创建一个更大的过滤器，再将所有历史元素批量add进行</li>
</ul>
<p><strong>使用场景:</strong></p>
<p>由于“有不一定有，无一定无”，场景为：</p>
<ul>
<li>放在redis前解决缓存穿透问题</li>
<li>黑名单校验，识别垃圾邮件</li>
<li>存放安全连接网址，访问时如果不在过滤器里则不允许访问。</li>
</ul>
<h1 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h1><p><strong>1. 基本原理</strong></p>
<p>布谷鸟过滤器基于<strong>布谷哈希（Cuckoo Hashing）</strong>技术。其核心思想是利用两个哈希函数来确定元素可以放置的位置，并通过“踢出”机制解决冲突问题。每个元素的指纹（fingerprint）被存储在一个或另一个位置上，如果这两个位置都已满，则会随机选择一个位置的元素进行替换并尝试将其重新定位到它的另一个可能位置。</p>
<p><strong>主要组成部分</strong></p>
<ul>
<li><strong>桶（Bucket）</strong>：布谷鸟过滤器的基本存储单元，通常每个桶可以存储多个指纹。</li>
<li><strong>指纹（Fingerprint）</strong>：每个元素通过哈希计算得到的一个较短的二进制串，用来代表该元素。</li>
<li><strong>哈希函数</strong>：使用两个独立的哈希函数生成两个不同的索引位置。</li>
</ul>
<p><strong>2. 工作流程</strong></p>
<p><strong>（1）插入</strong></p>
<ol>
<li>对于要插入的元素，首先计算其两个哈希值，从而确定两个可能的桶位置。</li>
<li>检查这两个位置是否有一个未满。如果有，则将该元素的指纹插入其中。</li>
<li>如果两个位置都满了，则随机选择一个位置的现有指纹进行“踢出”，并将新元素的指纹放入这个位置。</li>
<li>被踢出的指纹需要根据其自身的哈希值找到新的位置，并重复上述过程。</li>
<li>如果经过多次尝试后仍无法完成插入（达到最大迭代次数），则认为过滤器已满，可能需要扩展容量或调整参数。</li>
</ol>
<p><strong>（2）查找</strong></p>
<ol>
<li>计算待查找元素的两个哈希值。</li>
<li>检查对应的两个桶中是否有匹配的指纹存在。</li>
<li>如果任何一个桶中找到了匹配的指纹，则认为该元素可能存在；否则，确认该元素不存在。</li>
</ol>
<p><strong>（3）删除</strong></p>
<ol>
<li>同样计算元素的两个哈希值。</li>
<li>在对应的两个桶中寻找匹配的指纹。</li>
<li>找到后直接从桶中移除该指纹即可。</li>
</ol>
<ul>
<li><strong>指纹长度的影响</strong>：布谷鸟过滤器中使用的指纹长度是一个关键因素。较短的指纹意味着更高的碰撞几率，从而导致较高的误报率。相反，较长的指纹虽然降低了误报率，但增加了存储开销。</li>
<li><strong>负载因子</strong>：布谷鸟过滤器的性能和误报率还受其负载因子（即填充程度）的影响。高负载因子可能导致更多的踢出操作，进而增加误报的可能性。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://mutesniper.github.io">Muite</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://mutesniper.github.io/2025/04/19/redis%E8%A1%A5%E5%85%85/">https://mutesniper.github.io/2025/04/19/redis%E8%A1%A5%E5%85%85/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">note</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://img.alicdn.com/bao/uploaded/i3/2200690044395/O1CN012NL22Q1iKxHYWb17f_!!2200690044395.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/19/maven/" title="笔记-maven"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">笔记-maven</div></div><div class="info-2"><div class="info-item-1">简介在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons...</div></div></div></a><a class="pagination-related" href="/2025/04/19/tomcat%E5%8E%9F%E7%90%86/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/19/Redis/" title="笔记-Redis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2">笔记-Redis</div></div><div class="info-2"><div class="info-item-1">初识redisNoSQL   数据结构：SQL可以使用字段、约束保持结构化；NoSQL根据不同类型的数据库有不同的结构  数据关联：SQL表之间能够以外键互相关联；NoSQL本身不支持相互关联，需要编写逻辑进行关联。  事务特性： BASE理论是针对大规模分布式系统的三个主要属性的缩写，它代表了基本可用（Basically Available）、软状态（Soft state）、最终一致性（Eventual consistency）。BASE理论与ACID（原子性、一致性、隔离性、持久性）原则相对，更强调系统在分区容错性下的可用性和数据的灵活性。以下是BASE理论的三个组成部分的详细介绍：  基本可用（Basically Available）： 基本可用是指分布式系统在出现故障时，仍能保证提供部分功能服务，而不是完全不可用。这意味着系统可以损失一些非关键的功能或性能来确保核心服务的可用性。   软状态（Soft...</div></div></div></a><a class="pagination-related" href="/2025/04/19/redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%8F%8A%E5%8E%9F%E7%90%86/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">Redis最佳实践Redis键值设计key结构Redis的key虽然可以自定义，但最好遵循下面几个最佳实践约定  遵循基本格式：[业务名称]：[数据名]：[id] 不包含特殊字符  拒绝BigKeyBigKey的定义（不绝对）     BigKey的危害：   发现BigKey：   删除bigkey: 非字符串的bigkey，不要使用del删除，而是使用hscan、sscan、zscan方式渐进式删除。 同时要防止bigkey过期时间自动删除问题（比如200万的zset设置1小时过期，会触发del操作，造成阻塞）  String：一般用del，如果过于庞大用unlink UNLINK 是 Redis 中用于异步删除键的一个命令，它在 Redis 4.0 版本中被引入。与传统的 DEL 命令不同，UNLINK 不会阻塞 Redis 主线程来执行键的删除操作，而是将键的删除任务放到后台线程池中异步处理。这使得 UNLINK 在处理大键（Bigkey）或需要大量时间来删除的键时特别有用，因为它可以显著减少对 Redis 性能的影响。   对于list、set、hash、sorted...</div></div></div></a><a class="pagination-related" href="/2025/04/19/String/" title="笔记-String"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2">笔记-String</div></div><div class="info-2"><div class="info-item-1">String:特性： 内容不会发生改变，它的对象在创建后不能被更改。如果进行修改则会创建一个新的字符串变量。 由于String对象不可变，所以它是线程安全的。  创建方法： 直接赋值： 1String name=&quot;... &quot;;  构造方法： 1234public String()public String(String original)public String(char[] chs)public String (byte[] chs)  方法： 获取长度：1str.length() 查找子串:1234//返回第一个指定字串的索引str.indexOf...</div></div></div></a><a class="pagination-related" href="/2025/04/19/MyBatis/" title="笔记-MyBatis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2">笔记-MyBatis</div></div><div class="info-2"><div class="info-item-1">简介MyBatis是持久层框架（和数据库进行交互的框架） MyBatis 不像 Hibernete 等这些全自动框架，它把关键的SQL部分交给程序员自己编写，而不是自动生成  HelloWorld步骤：  导入mybatis依赖  配置数据源  编写javabean对应数据库一个表模型  以前：Dao接口–&gt;Dao实现  。–&gt;标注@Repository注解 现在：Mapper接口–&gt;Mapper.xml实现 ,–&gt;标注@Mapper注解 （安装mybatisx插件自动为mapper类生成mapper文件，我们只需要在mapper文件中配置方法的sql语句）  告诉mybatis去哪里找mapper文件：mybatis.mapper-locations=classpath:mapper/**.xml   mapper接口： 1234@Mapper //告诉spring，这是MyBatis操作数据库用的接口public interface EmpMapper &#123;    Emp getEmpById(Integer...</div></div></div></a><a class="pagination-related" href="/2025/03/17/maven%E5%9F%BA%E7%A1%80/" title="JAVA学习笔记-maven基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">JAVA学习笔记-maven基础</div></div><div class="info-2"><div class="info-item-1">简介在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons...</div></div></div></a><a class="pagination-related" href="/2025/04/19/git/" title="笔记-git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2">笔记-git</div></div><div class="info-2"><div class="info-item-1">简介Git: 一个分布式版本控制系统 集中式vs分布式：  集中式: 版本库集中存放在中央服务器，使用时，从中央服务器获取最新的版本，修改完后，再推送给中央服务器。且集中式版本控制系统必须联网才能工作，不方便。 分布式：每个人的电脑都有一个完整的版本库，所以工作时不需要联网。将仓库进行同步就可以完成多人协作，但其实并不常用这种方法，而是通过一台充当“中央服务器”的电脑来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。  Git安装Linux 下安装输入git,查看是否已经安装Git: 123$ gitThe program &#x27;git&#x27; is currently not installed. You can install it by typing:sudo apt-get install git  像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://img.alicdn.com/bao/uploaded/i3/2200690044395/O1CN012NL22Q1iKxHYWb17f_!!2200690044395.jpg" onerror="this.onerror=null;this.src='/null'" alt="avatar"/></div><div class="author-info-name">Muite</div><div class="author-info-description">keep learning</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mutesniper"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/mutesniper" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">Redis事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BigKey"><span class="toc-number">2.</span> <span class="toc-text">BigKey</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MoreKey"><span class="toc-number">2.1.</span> <span class="toc-text">MoreKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigKey%EF%BC%88%E5%9C%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%E4%B8%AD%E5%B7%B2%E6%8F%90%E5%88%B0%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">BigKey（在最佳实践笔记中已提到）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigKey%E7%94%9F%E4%BA%A7%E8%B0%83%E4%BC%98"><span class="toc-number">2.3.</span> <span class="toc-text">BigKey生产调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.</span> <span class="toc-text">原理&amp;使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">布谷鸟过滤器</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/19/spring%20security/" title="Untitled">Untitled</a><time datetime="2025-04-19T09:22:50.057Z" title="Created 2025-04-19 17:22:50">2025-04-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/19/MySQL%E8%BF%9B%E9%98%B6/" title="Untitled">Untitled</a><time datetime="2025-04-19T09:22:50.048Z" title="Created 2025-04-19 17:22:50">2025-04-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/19/String/" title="笔记-String">笔记-String</a><time datetime="2025-04-19T04:46:00.000Z" title="Created 2025-04-19 12:46:00">2025-04-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/19/MyBatis/" title="笔记-MyBatis">笔记-MyBatis</a><time datetime="2025-04-19T04:46:00.000Z" title="Created 2025-04-19 12:46:00">2025-04-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/19/git/" title="笔记-git">笔记-git</a><time datetime="2025-04-19T04:46:00.000Z" title="Created 2025-04-19 12:46:00">2025-04-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Muite</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>